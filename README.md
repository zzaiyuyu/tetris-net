## “直播”俄罗斯方块

**展示图片在项目文件夹里**

项目概述：类似于当前火热的直播平台，该项目由一个服务端，两种客户端构成。直播的玩家选择直播客户端，输入房间号，在本机运行俄罗斯方块游戏。观看直播的人登录观战客户端，输入想看的直播房号，进入可以实时观看到“主播”的游戏实况。

主要技术：

1. 服务端用epoll IO多路转接模型进行编写，可高效处理不同的连接请求以及数据分发
2. 服务端用位图标记已使用和未使用的房间号，实现O(1)查询。并且维护多个观战者队列
3. 游戏主体采用MVC设计思路，通过定时机制，设置非阻塞IO，设置终端属性完成游戏主体部分

项目收获：

1. 服务端部分架构的设计受益匪浅，从更深层次理解TCP/IP协议以及epoll原理
2. 使用信号捕捉机制处理服务端，客户端异常连接问题。进程向收到RST的套接字继续执行写操作会收到SIGPIPE信号。
3. 学习将合理的数据结构放到适用的位置，实现功能的同时考虑高性能
4. 熟练掌握Linux环境C/C++开发工具 gcc， makefile， vim， 以及代码托管工具 git 

展示及代码地址：https://github.com/zzaiyuyu/tetris-net/

使用说明：

```
./server 8080
./client 127.0.0.1 8080
./viewer 127.0.0.1 8080
```

**单机版设计思路：**

model部分

每一个图形用一个5X5数组表示，有图案则置为1，无则0.这样总共可以把全部的7类图形用一个结构体数组描述出来。

同时游戏还需要当前正在下落的图案的坐标。

------

control部分

**主流程：**

主控制逻辑设置一个**定时器**，并且捕捉ALRM信号，每过一定时间就自动下落一格。

下落过程中需要判断下一个位置是不是可以走，如果可以走，就擦出当前图案，在下一个位置画出来，如果不能走，就是碰到物体了，需要检测是不是该消除，游戏结束，之后就要开始下一个块了。

其中在判断下一步是否可行时，需要当前整个图案信息才能判断是否碰到物体了，所以在每一次碰到物体首先要保存当前的整体背景。

**如何控制方向？**

在主控流程加一个死循环，不断的判断是否有按键产生。判断按键首先要**设置终端模式**，标准输入是键盘输入到内核缓存，输入回车后才进入程序地址空间，将其改为键盘输入直接进入应用程序。然后**非阻塞**的读取输入程序地址的输入缓存区。

假如按了左键，首先判断下一个位置可行不可行，若是非法操作，则恢复上一个图案。假如按上键，利用旋转函数对当前图案进行**旋转**。

**如何设置不同颜色块，显示下一个形状？**

在定时下落的函数里，如果碰到不能走的情况，说明要出下一个块了，此时设置一个随机数，造成不同颜色块的效果。同理只需要一个临时变量nextBuf即可记录下一个形状。

------

view部分

VT100 实现终端画布式打印

**直播版思路：**


基于TCP连接的服务器，客户端模型。

**玩家客户端**创建套接字，三次挥手建立连接请求。首先发送一个请求创建直播间信息，成功后开始运行本地游戏主体，每当有图案变化产生，向服务器**序列化**发送图案信息。

**观战客户端**建立连接后首先发送请求加入直播间的消息，成功后阻塞读取套接字内容，直到有数据到来，更新图案。

**服务器**用epoll多路IO转接，对监听套接字送上来的连接创建套接字后同一做读事件监听。之后按客户端发的消息类型进行区分，

1. 代表请求创建直播间，之后不断监听玩家套接字
2. 请求加入直播间，之后不断监听读事件向其发送图案信息
3.  我是图案信息,需要转发给房间内的所有人

将套接字映射到房间号，通过房间号获取观战队列句柄。